<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StacKAT</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.23.0/cytoscape.min.js"></script>
    <!-- Added modern font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script>
        function replacer(key, value) {
            if (value instanceof Map) {
                return {
                    dataType: 'Map',
                    value: Array.from(value.entries())
                };
            } else {
                return value;
            }
        }

        function hash(obj) {
            return JSON.stringify(obj, replacer);
        }


        let nodeCache = new Map();
        function mk(type, ...args) {
            let node = [type, ...args];
            let key = hash(node);
            if (!nodeCache.has(key)) {
                nodeCache.set(key, node);
            }
            return nodeCache.get(key);
        }

        const zero = mk('zero');
        const one = mk('one');
        const push = (n) => mk('push', n);
        const pop = (n) => mk('pop', n);
        const test = (id, n) => mk('test', id, n);
        const testNE = (id, n) => mk('testNE', id, n);
        const mut = (id, n) => mk('mut', id, n);
        const alt = (a, b) => mk('alt', a, b);
        const seq = (a, b) => mk('seq', a, b);
        const star = (a) => mk('star', a);

        const pair = (a, b) => mk('pair', a, b);


        class ParseError extends Error {
            constructor(message, index, input) {
                super(message);
                this.index = index;
                this.input = input;
            }
        }

        function parse(input) {
            let current = 0;
            function error(message) {
                throw new ParseError(message, current, input);
            }
            function ws() {
                while (current < input.length && (input[current] == ' ' || input[current] == '\n')) {
                    current++;
                }
            }
            function tok(str) {
                let oldCurrent = current;
                ws();
                let i = 0;
                while (true) {
                    if (i < str.length) {
                        if (current < input.length && str[i] == input[current]) {
                            i++; current++;
                        } else {
                            current = oldCurrent;
                            return false;
                        }
                    } else {
                        return str;
                    }
                }
            }
            function expect(str) {
                let token = tok(str);
                if (token) {
                    return token;
                } else {
                    error('Expecting <code>' + str + '</code>');
                }
            }
            function num() {
                let oldCurrent = current;
                ws();
                let str = '';
                while (current < input.length && /[0-9]/.test(input[current])) {
                    str += input[current];
                    current++;
                }
                if (str == '') {
                    current = oldCurrent;
                    return false;
                } else {
                    return parseInt(str);
                }
            }
            function expectNum() {
                let n = num();
                if (n !== false) {
                    return n;
                } else {
                    error('Expecting a number')
                }
            }
            function ident() {
                let oldCurrent = current;
                ws();
                if (current < input.length && /[a-zA-Z]/.test(input[current])) {
                    let str = input[current];
                    current++;
                    while (current < input.length && /[0-9a-zA-Z]/.test(input[current])) {
                        str += input[current];
                        current++;
                    }
                    return str;
                } else {
                    current = oldCurrent;
                    return false;
                }
            }
            function atom() {
                if (tok('(')) {
                    let e = expression(0);
                    if (!e) {
                        error('Expecting an expression')
                    }
                    if (!tok(')')) {
                        error('Expecting <code>)</code> or another expression')
                    }
                    return e;
                } else if (tok('0')) {
                    return zero;
                } else if (tok('1')) {
                    return one
                } else if (tok('push')) {
                    expect('(')
                    let n = expectNum();
                    expect(')');
                    return push(n)
                } else if (tok('pop')) {
                    expect('(')
                    let n = expectNum();
                    expect(')');
                    return pop(n)
                } else {
                    let oldCurrent = current;
                    let id = ident();
                    if (!id) { return false; }
                    if (tok('==')) {
                        let n = expectNum();
                        return test(id, n);
                    } else if (tok('!=')) {
                        let n = expectNum();
                        return testNE(id, n);
                    } else if (tok(':=')) {
                        let n = expectNum();
                        return mut(id, n);
                    } else {
                        current = oldCurrent;
                        return false;
                    }
                }
            }
            function expression(bp) {
                let left = atom();
                if (!left) { return false; }
                while (true) {
                    if (bp <= 0 && tok('+')) {
                        ws();
                        let right = expression(0);
                        if (right) {
                            left = alt(left, right);
                        } else {
                            error('Expecting an expression')
                        }
                    } else if (bp <= 20 && tok('*')) {
                        left = star(left)
                    } else if (bp <= 10) {
                        let right = expression(10);
                        if (right) {
                            left = seq(left, right);
                        } else {
                            return left;
                        }
                    } else {
                        return left;
                    }
                }
            }
            let e = expression(0);
            ws();
            if (current < input.length) {
                error('Expecting an expression or end of input')
            }
            return e;
        }

        const parens = (bool, str) => bool ? `(${str})` : str;
        function pretty(expr, bp = 0) {
            switch (expr[0]) {
                case 'zero': return '0';
                case 'one': return '1';
                case 'push': return `push(${expr[1]})`;
                case 'pop': return `pop(${expr[1]})`;
                case 'test': return parens(bp >= 20, `${expr[1]}==${expr[2]}`);
                case 'testNE': return parens(bp >= 20, `${expr[1]}!=${expr[2]}`);
                case 'mut': return parens(bp >= 20, `${expr[1]}:=${expr[2]}`);
                case 'alt': return parens(bp > 0, `${pretty(expr[1], 0)} + ${pretty(expr[2], 0)}`);
                case 'seq': return parens(bp > 10, `${pretty(expr[1], 10)} ${pretty(expr[2], 10)}`);
                case 'star': return parens(bp > 20, `${pretty(expr[1], 20)}*`);
                case 'pair':
                    let left = expr[1] == one ? 'ε' : expr[1][1];
                    let right = expr[2] == one ? 'ε' : expr[2][1];
                    return `${left}/${right}`;
                // if(expr[1] == one) return `□${pretty(expr[2])}`;
                // if(expr[2] == one) return `${pretty(expr[1])}□`;
                // return `${pretty(expr[1])}□${pretty(expr[2])}`;
            }
        }

        function E(expr, pk) {
            switch (expr[0]) {
                case 'zero': return [];
                case 'one': return [pk];
                case 'push': return [];
                case 'pop': return [];
                case 'test': return pk.get(expr[1]) == expr[2] ? [pk] : [];
                case 'testNE': return pk.get(expr[1]) != expr[2] ? [pk] : [];
                case 'mut':
                    let newPk = new Map(pk);
                    newPk.set(expr[1], expr[2]);
                    return [newPk];
                case 'alt': return E(expr[1], pk).concat(E(expr[2], pk));
                case 'seq':
                    return E(expr[1], pk).flatMap(pk1 => E(expr[2], pk1));
                case 'star':
                    let res = new Map();
                    res.set(hash(pk), pk);
                    let todo = [pk];
                    while (todo.length > 0) {
                        let pk1 = todo.pop();
                        for (let pk2 of E(expr[1], pk1)) {
                            let key = hash(pk2)
                            if (!res.has(key)) {
                                res.set(key, pk2);
                                todo.push(pk2);
                            }
                        }
                    }
                    return Array.from(res.values());
            }
        }

        function D(expr, pk) {
            switch (expr[0]) {
                case 'zero': return [];
                case 'one': return [];
                case 'push':
                    return [[expr, [one, pk]]];
                case 'pop':
                    return [[expr, [one, pk]]];
                case 'test': return [];
                case 'testNE': return [];
                case 'mut': return [];
                case 'alt': return D(expr[1], pk).concat(D(expr[2], pk));
                case 'seq':
                    let d1 = D(expr[1], pk).map(([trans, [expr1, pk1]]) => [trans, [seq(expr1, expr[2]), pk1]]);
                    let e1 = E(expr[1], pk);
                    let d2 = e1.flatMap(pk1 => D(expr[2], pk1));
                    return d1.concat(d2);
                case 'star':
                    let e = E(expr, pk);
                    return e.flatMap(pk1 => D(expr[1], pk1).map(([trans, [expr2, pk2]]) => [trans, [seq(expr2, expr), pk2]]));
            }
        }

        function dom(expr) {
            let res = new Map();
            function iter(e) {
                switch (e[0]) {
                    case 'zero': return;
                    case 'one': return;
                    case 'push': return;
                    case 'pop': return;
                    case 'test':
                        if (!res.has(e[1])) res.set(e[1], new Set());
                        res.get(e[1]).add(e[2]);
                    case 'testNE':
                        if (!res.has(e[1])) res.set(e[1], new Set());
                        res.get(e[1]).add(e[2]);
                    case 'mut':
                        if (!res.has(e[1])) res.set(e[1], new Set());
                        res.get(e[1]).add(e[2]);
                    case 'alt': iter(e[1]); iter(e[2]); return;
                    case 'seq': iter(e[1]); iter(e[2]); return;
                    case 'star': iter(e[1]); return;
                }
            }
            iter(expr);
            return res;
        }

        function getValues(expr) {
            // returns all the values used in push/pop in expr and v
            let res = new Set();
            function iter(e) {
                switch (e[0]) {
                    case 'zero': return;
                    case 'one': return;
                    case 'push': res.add(e[1]); return;
                    case 'pop': res.add(e[1]); return;
                    case 'test': return;
                    case 'mut': return;
                    case 'alt': iter(e[1]); iter(e[2]); return;
                    case 'seq': iter(e[1]); iter(e[2]); return;
                    case 'star': iter(e[1]); return;
                }
            }
            iter(expr);
            res.add("?");
            // convert to array
            return Array.from(res);
        }

        function automaton(expr, inpk, outpk) {
            // Computes an automaton from an expression, going from inpk to outpk
            let aut = new Map();
            let final = new Set();
            let todo = [[expr, inpk]];
            while (todo.length > 0) {
                let [ee, pk] = todo.pop();
                let key = hash([ee, pk]);
                if (aut.has(key)) continue
                let ds = D(ee, pk);
                aut.set(key, ds.map(([trans, state]) => [trans, hash(state)]));
                for (let [trans, state] of ds) {
                    todo.push(state);
                }
                let es = E(ee, pk);
                for (let pk1 of es) {
                    // check if outpk is equal to pk2, but compare them as maps
                    if (hash(pk1) == hash(outpk)) {
                        final.add(key);
                    }
                }
            }
            return { start: hash([expr, inpk]), aut, final };
        }

        function pushpop(automaton) {
            // computes the push-pop closure of an automaton
            // first, copy the automaton, adding epsilon transitions
            let { start: start0, aut: aut0, final: final0 } = automaton;
            let aut = new Map();
            for (const [key, ds] of aut0.entries()) {
                aut.set(key, [[one, key], ...ds]);
            }
            let changed = true;
            function addEpsilon(key1, key2) {
                let ds = aut.get(key1);
                for (let [trans, key3] of ds) {
                    if (trans == one && key3 == key2) return;
                }
                ds.push([one, key2]);
                changed = true;
            }
            let fuel = 100;
            while (changed) {
                fuel -= 1;
                if (fuel <= 0) {
                    console.log('Fuel exhausted in pushpop');
                    break;
                    // throw new Error('Fuel exhausted in pushpop');
                }
                changed = false;
                for (let [key1, ds1] of aut.entries()) {
                    // shortcut push-eps-pop
                    for (let [trans1, key2] of ds1) {
                        if (trans1[0] == 'push') {
                            for (let [trans2, key3] of aut.get(key2)) {
                                if (trans2 == one) {
                                    for (let [trans3, key4] of aut.get(key3)) {
                                        if (trans3[0] == 'pop' && trans3[1] == trans1[1]) {
                                            addEpsilon(key1, key4);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // shortcut eps-eps
                    for (let [trans1, key2] of ds1) {
                        if (trans1 == one) {
                            for (let [trans2, key3] of aut.get(key2)) {
                                if (trans2 == one) {
                                    addEpsilon(key1, key3);
                                }
                            }
                        }
                    }
                }
            }
            return { start: start0, aut: aut, final: final0 };
        }

        function zip(automaton) {
            let { start: start0, aut: aut0, final: final0 } = automaton;
            // build reverse transitions into aut0rev
            let aut0rev = new Map();
            for (let [key, ds] of aut0.entries()) {
                if (!aut0rev.has(key)) aut0rev.set(key, []);
                for (let [trans, key1] of ds) {
                    if (!aut0rev.has(key1)) aut0rev.set(key1, []);
                    aut0rev.get(key1).push([trans, key]);
                }
            }
            let aut = new Map();
            aut.set('start', []);
            let todo = []
            function addState([key1, key2]) {
                let key = hash([key1, key2]);
                if (aut.has(key)) return;
                aut.set(key, []);
                todo.push([key1, key2]);
            }
            function addTransition([key1, key2], [key3, key4], trans) {
                addState([key3, key4]);
                aut.get(hash([key1, key2])).push([trans, hash([key3, key4])]);
            }
            for (let key of aut0.keys()) {
                addState([key, key])
                aut.get('start').push([one, hash([key, key])]);
            }
            while (todo.length > 0) {
                let [key1, key2] = todo.pop();
                // if key1 is the start state, add a transition to ['done', key2]
                if (key1 == start0) {
                    addTransition([key1, key2], ['done', key2], one);
                }
                // if key2 is a final state, add a transition to [key1, 'done']
                if (final0.has(key2)) {
                    addTransition([key1, key2], [key1, 'done'], one);
                }
                if (key1 == 'done' && key2 != 'done') {
                    let ds2 = aut0.get(key2);
                    for (let [trans2, key3] of ds2) {
                        if (trans2[0] == 'push') {
                            addTransition(['done', key2], ['done', key3], pair(one, trans2));
                        } else if (trans2 == one) {
                            addTransition(['done', key2], ['done', key3], one);
                        }
                    }
                }
                if (key1 != 'done' && key2 == 'done') {
                    let ds1 = aut0rev.get(key1);
                    for (let [trans1, key3] of ds1) {
                        if (trans1[0] == 'pop') {
                            addTransition([key1, 'done'], [key3, 'done'], pair(trans1, one));
                        } else if (trans1 == one) {
                            addTransition([key1, 'done'], [key3, 'done'], one);
                        }
                    }
                }
                if (key1 != 'done' && key2 != 'done') {
                    let ds1 = aut0rev.get(key1);
                    for (let [trans1, key3] of ds1) {
                        if (trans1 == one) {
                            addTransition([key1, key2], [key3, key2], one);
                        }
                    }
                    let ds2 = aut0.get(key2);
                    for (let [trans2, key] of ds2) {
                        if (trans2 == one) {
                            addTransition([key1, key2], [key1, key], one);
                        }
                    }
                    for (let [trans1, key3] of ds1) {
                        for (let [trans2, key4] of ds2) {
                            // if trans1 is pop and trans2 is push, add a transition
                            if (trans1[0] == 'pop' && trans2[0] == 'push') {
                                addTransition([key1, key2], [key3, key4], pair(trans1, trans2));
                            }
                        }
                    }
                }
            }
            return { start: 'start', aut, final: new Set([hash(['done', 'done'])]) };
        }

        function addStartLoopsMut(automaton, values) {
            let { start, aut, final } = automaton;
            // add (pop(i), push(i)) transitions for all i in values from start to start
            for (let i of values) {
                aut.get(start).push([pair(pop(i), push(i)), start]);
            }
        }

        function removeEps(automaton) {
            let { start: start0, aut: aut0, final: final0 } = automaton;
            let aut = new Map();
            let final = new Set();
            let todo = [[start0, start0]]
            let seen = new Set();
            while (todo.length > 0) {
                let [orig, key] = todo.pop();
                if (!aut.has(orig)) aut.set(orig, []);
                let hashKey = hash([orig, key]);
                if (seen.has(hashKey)) continue;
                seen.add(hashKey);
                let ds = aut0.get(key);
                for (let [trans, key1] of ds) {
                    if (trans == one) {
                        todo.push([orig, key1]);
                    } else {
                        // add transition if not already present
                        if (aut.get(orig).every(([trans2, key2]) => hash(trans2) != hash(trans) || key2 != key1)) {
                            aut.get(orig).push([trans, key1]);
                        }
                        todo.push([key1, key1]);
                    }
                }
                if (final0.has(key)) {
                    final.add(orig);
                }
            }
            return { start: start0, aut, final };
        }

        function removeDead(automaton) {
            let { start: start0, aut: aut0, final: final0 } = automaton;
            // build reverse transitions into aut0rev
            let aut0rev = new Map();
            for (let [key, ds] of aut0.entries()) {
                if (!aut0rev.has(key)) aut0rev.set(key, []);
                for (let [trans, key1] of ds) {
                    if (!aut0rev.has(key1)) aut0rev.set(key1, []);
                    aut0rev.get(key1).push([trans, key]);
                }
            }
            // flood fill from final states
            let todo = Array.from(final0);
            let seen = new Set([]);
            while (todo.length > 0) {
                let key = todo.pop();
                if (seen.has(key)) continue;
                seen.add(key);
                for (let [trans, key1] of aut0rev.get(key)) {
                    todo.push(key1);
                }
            }
            // remove unreachable states
            let aut = new Map();
            for (let [key, ds] of aut0.entries()) {
                if (seen.has(key)) {
                    aut.set(key, ds.filter(([trans, key1]) => seen.has(key1)));
                }
            }
            if (!seen.has(start0)) {
                aut.set(start0, []);
            }
            return { start: start0, aut, final: final0 };
        }

        function sortUniq(arr) {
            return Array.from(new Set(arr)).sort();
        }

        function determinize(automaton) {
            let { start: start0, aut: aut0, final: final0 } = automaton;
            let aut = new Map();
            let final = new Set();
            let todo = [[start0]];
            let seen = new Set();
            while (todo.length > 0) {
                let keys = todo.pop();
                // make keys final if any of the keys is final
                if (keys.some(key => final0.has(key))) {
                    final.add(keys.join(','));
                }
                let key = keys.join(',');
                if (seen.has(key)) continue;
                seen.add(key);
                let ds = new Map();
                for (let key1 of keys) {
                    for (let [trans, key2] of aut0.get(key1)) {
                        // if already present, continue
                        if (ds.has(hash(trans))) continue;
                        // add the transition on trans
                        // we have to do trans on all the states in keys
                        let newKeys = [];
                        for (let key3 of keys) {
                            for (let [trans1, key4] of aut0.get(key3)) {
                                if (hash(trans1) == hash(trans)) {
                                    newKeys.push(key4);
                                }
                            }
                        }
                        newKeys = sortUniq(newKeys);
                        ds.set(hash(trans), [trans, newKeys.join(",")]);
                        todo.push(newKeys);
                    }
                }
                aut.set(key, Array.from(ds.values()));
            }
            return { start: start0, aut, final };
        }

        function mergeRedundantEdges(automaton) {
            // merges edges such as 5,5 into v,v
            let { start, aut: aut0, final } = automaton;
            let aut = new Map();
            for (let [key, ds] of aut0.entries()) {
                let vvTargets = new Set();
                for (let [trans, key1] of ds) {
                    if (trans == pair(pop("?"), push("?"))) {
                        vvTargets.add(key1);
                    }
                }
                let newDs = [];
                for (let [trans, key1] of ds) {
                    if (trans[1][1] != trans[2][1] || !vvTargets.has(key1) || trans[1][1] == "?") {
                        newDs.push([trans, key1]);
                    }
                }
                aut.set(key, newDs);
            }
            return { start, aut, final };
        }

        function minimize(automaton) {
            let { start: start0, aut: aut0, final: final0 } = automaton;
            let eclass = new Map();
            for (let key of aut0.keys()) {
                eclass.set(key, 0);
            }
            function sig(key) {
                let sig = aut0.get(key).map(([trans, key1]) => hash([trans, eclass.get(key1)]));
                sig.sort();
                let sigstr = sig.join(',');
                let finalstr = final0.has(key) ? '|1' : '|0';
                sigstr += finalstr;
                return sigstr;
            }
            let fuel = 100;
            while (true) {
                fuel -= 1;
                let i = 0;
                let sigmap = new Map();
                for (let key of aut0.keys()) {
                    // build the signature of key
                    let sigstr = sig(key);
                    if (!sigmap.has(sigstr)) {
                        sigmap.set(sigstr, i);
                        i += 1;
                    }
                }
                let neweclass = new Map();
                for (let key of aut0.keys()) {
                    let sigstr = sig(key);
                    neweclass.set(key, sigmap.get(sigstr));
                }
                if (hash(eclass) == hash(neweclass)) {
                    break;
                } else {
                    eclass = neweclass;
                }
                if (fuel < 0) {
                    console.log('Fuel exhausted in minimize');
                    return;
                }
            }
            function name(key) {
                return `s${eclass.get(key).toString()}`;
            }
            let aut = new Map();
            for (let [key, ds] of aut0.entries()) {
                aut.set(name(key), aut0.get(key).map(([trans, key2]) => [trans, name(key2)]))
            }
            let final = new Set(Array.from(final0).map(key => name(key)));
            let start = name(start0);
            return { start, aut, final };
        }

        function shortestDifferingPath(automaton1, automaton2) {
            // returns the shortest string that is accepted by automaton1 but not by automaton2
            // if no such string exists, returns false
            // automaton1 and automaton2 must be deterministic automata
            let { start: start1, aut: aut1, final: final1 } = automaton1;
            let { start: start2, aut: aut2, final: final2 } = automaton2;
            let todo = [[start1, start2, []]];
            let seen = new Set();
            while (todo.length > 0) {
                let [key1, key2, path] = todo.shift();
                console.log("comparison", key1, key2, path)
                let key = hash([key1, key2]);
                if (seen.has(key)) continue;
                seen.add(key);
                if (final1.has(key1) && !final2.has(key2)) {
                    return path;
                }
                for (let [trans1, key3] of aut1.get(key1)) {
                    if (!aut2.has(key2)) {
                        todo.push([key3, "dead", path.concat([trans1])]);
                        continue;
                    }
                    let found = false;
                    for (let [trans2, key4] of aut2.get(key2)) {
                        if (hash(trans1) == hash(trans2)) {
                            todo.push([key3, key4, path.concat([trans1])]);
                            found = true;
                        }
                    }
                    if (!found) {
                        todo.push([key3, "dead", path.concat([trans1])]);
                    }
                }
            }
            return false;
        }

        function automatonToCytoscape(aut) {
            let nodes = [];
            let edges = [];
            for (let [key, ds] of aut.aut.entries()) {
                let classes = [];
                let tooltip = '';

                // Create a more readable state ID for display
                let displayId = key;
                try {
                    // Try to parse if it's a JSON string (for automaton states)
                    const parsedId = JSON.parse(key);
                    if (typeof parsedId === 'object') {
                        displayId = 'State ' + (nodes.length + 1);
                    }
                } catch (e) {
                    // Not JSON, use as is
                }

                if (aut.final.has(key) && key == aut.start) {
                    classes.push('accept', 'start');
                    tooltip = '<strong>Initial and accepting state</strong>';
                } else if (aut.final.has(key)) {
                    classes.push('accept');
                    tooltip = '<strong>Accepting state</strong>';
                } else if (key == aut.start) {
                    classes.push('start');
                    tooltip = '<strong>Initial state</strong>';
                } else {
                    tooltip = '<strong>Intermediate state</strong>';
                }

                nodes.push({
                    data: {
                        id: key,
                        label: '',
                        tooltip: tooltip
                    },
                    classes: classes.join(' ')
                });
            }
            let i = 0;
            for (let [key, ds] of aut.aut.entries()) {
                for (let [trans, state] of ds) {
                    i += 1;
                    edges.push({ data: { id: i, source: key, target: state, label: pretty(trans) } });
                }
            }
            return { nodes, edges };
        }

        function minaut(result, values, inpk, outpk) {
            let aut = automaton(result, inpk, outpk)
            aut = pushpop(aut);
            aut = zip(aut);
            addStartLoopsMut(aut, values);
            aut = removeEps(aut);
            aut = removeDead(aut);
            aut = determinize(aut);
            aut = minimize(aut);
            return aut;
        }

        function decidePk(expr1, expr2, inpk, outpk) {
            let values = Array.from(new Set(getValues(expr1).concat(getValues(expr2))));
            let aut1 = minaut(expr1, values, inpk, outpk);
            let aut2 = minaut(expr2, values, inpk, outpk);
            let path1 = shortestDifferingPath(aut1, aut2);
            let path2 = shortestDifferingPath(aut2, aut1);
            return [path1, path2];
        }

        function allpks(values) {
            // values is a map from strings to sets of values
            // we want to compute a list of maps with all possible values (like cartesian product)
            let keys = Array.from(values.keys());
            let pks = [new Map()];
            for (let key of keys) {
                let newpks = [];
                for (let pk of pks) {
                    for (let value of [...values.get(key), "?"]) {
                        let newpk = new Map(pk);
                        newpk.set(key, value);
                        newpks.push(newpk);
                    }
                }
                pks = newpks;
            }
            return pks;
        }

        function decide(expr1, expr2) {
            // first, compute the domain of all values in expr1 and expr2
            let dom1 = dom(expr1); // map from strings to sets of values
            let dom2 = dom(expr2);
            // union values2 into values1
            for (let [key, values] of dom2.entries()) {
                if (!dom1.has(key)) {
                    dom1.set(key, values);
                } else {
                    for (let value of values) {
                        dom1.get(key).add(value);
                    }
                }
            }
            // now, compute all possible pk's
            let pks = allpks(dom1);
            console.log("pks", pks)
            // now, decide for each pk
            let respath1 = false;
            let respks1 = false;
            let respath2 = false;
            let respks2 = false;
            for (let inpk of pks) {
                for (let outpk of pks) {
                    let [path1, path2] = decidePk(expr1, expr2, inpk, outpk);
                    console.log("expr1", expr1)
                    console.log("expr2", expr2)
                    console.log("inpk", inpk)
                    console.log("outpk", outpk)
                    console.log("path1X", path1)
                    console.log("path2X", path2)
                    if (path1) {
                        // update if path is shorter
                        if (!respath1 || path1.length < respath1.length) {
                            respath1 = path1;
                            respks1 = [inpk, outpk];
                        }
                    }
                    if (path2) {
                        // update if path is shorter
                        if (!respath2 || path2.length < respath2.length) {
                            respath2 = path2;
                            respks2 = [inpk, outpk];
                        }
                    }
                }
            }
            return [respath1, respks1, respath2, respks2];
        }

        function renameStates(aut) {
            let aut1 = new Map();
            let key2num = new Map();
            let num2key = new Map();
            let i = 0;
            for (let key of aut.aut.keys()) {
                key2num.set(key, i);
                num2key.set(i, key);
                i += 1;
            }
            for (let [key, ds] of aut.aut.entries()) {
                // console.log("ds", ds)
                let i = key2num.get(key);
                aut1.set(i, ds.map(([trans, key1]) => [trans, key2num.get(key1)]));
            }
            return { start: key2num.get(aut.start), aut: aut1, final: new Set(Array.from(aut.final).map(key => key2num.get(key))) };
        }

        function toGraphviz(aut0) {
            let aut = renameStates(aut0);
            let res = 'digraph {\n';
            res += '  rankdir=LR;\n';
            // final states
            res += '  node [shape=doublecircle];';
            for (let key of aut.final) {
                res += ' ' + key
            }
            res += ';\n';
            // add initial state incoming edge
            res += '  node [shape=point]; start;\n';
            // other states
            res += '  node [shape=circle];\n';
            res += '  start -> ' + aut.start + ';\n';
            // transitions
            for (let [key, ds] of aut.aut.entries()) {
                for (let [trans, key1] of ds) {
                    res += '  ' + key + ' -> ' + key1 + ' [label="' + pretty(trans) + '"];\n';
                }
            }
            res += '}\n';
            return res;
        }

        function decideLGE(expr1, expr2) {
            let [path1, respks1, path2, respks2] = decide(expr1, expr2);
            if (!path1 && !path2) {
                return "=";
            }
            if (path1 && !path2) {
                return ">";
            }
            if (!path1 && path2) {
                return "<";
            }
            if (path1 && path2) {
                return "!=";
            }
        }

        // unit tests
        function tests(){
            // Test decide_equivalence_all
            function test_decide_equivalence_all() {
                // Same tests as above, but for decide_equivalence_all
                let e1 = seq(star(pop("2")), star(push("2")));
                let e2 = star(alt(push("2"), pop("2")));
                let e3 = seq(star(push("2")), star(seq(pop("2"), pop("2"))));
                let e4 = seq(star(seq(pop("2"), pop("2"))), star(push("2")));
                let e5 = seq(star(seq(push("2"), push("2"))), star(pop("2")));
                let e6 = seq(star(pop("2")), star(seq(push("2"), push("2"))));

                console.assert(decideLGE(e1, e2) === "=");
                console.assert(decideLGE(e1, e3) === "=");
                console.assert(decideLGE(e1, e4) === ">");
                console.assert(decideLGE(e1, e5) === "=");
                console.assert(decideLGE(e1, e6) === ">");

                console.assert(decideLGE(e2, e3) === "=");
                console.assert(decideLGE(e3, e2) === "=");

                console.assert(decideLGE(e2, e4) === ">");
                console.assert(decideLGE(e4, e2) === "<");

                console.assert(decideLGE(e2, e5) === "=");
                console.assert(decideLGE(e5, e2) === "=");

                console.assert(decideLGE(e2, e6) === ">");
                console.assert(decideLGE(e6, e2) === "<");

                console.assert(decideLGE(e3, e4) === ">");
                console.assert(decideLGE(e4, e3) === "<");

                console.assert(decideLGE(e3, e5) === "=");
                console.assert(decideLGE(e5, e3) === "=");

                console.assert(decideLGE(e3, e6) === ">");
                console.assert(decideLGE(e6, e3) === "<");

                console.assert(decideLGE(e4, e5) === "<");
                console.assert(decideLGE(e5, e4) === ">");

                console.assert(decideLGE(e4, e6) === "!=");
                console.assert(decideLGE(e6, e4) === "!=");

                console.assert(decideLGE(e5, e6) === ">");
                console.assert(decideLGE(e6, e5) === "<");
            }

            // Test decide_equivalence_all_pure_headers
            function test_decide_equivalence_all_pure_headers() {
                let e1 = seq(mut("f", "2"), mut("g", "3"));
                let e2 = seq(mut("g", "3"), mut("f", "2"));
                console.assert(decideLGE(e1, e2) === "=");

                let e3 = seq(mut("f", "2"), test("f", "2"));
                let e4 = seq(mut("f", "2"), mut("f", "2"));
                console.assert(decideLGE(e3, e4) === "=");

                let e5 = seq(star(mut("f", "2")), mut("g", "3"));
                let e6 = seq(mut("g", "3"), star(mut("f", "2")));
                console.assert(decideLGE(e5, e6) === "=");

                let e7 = star(alt(mut("f", "2"), mut("g", "3")));
                let e8 = star(alt(mut("g", "3"), mut("f", "2")));
                console.assert(decideLGE(e7, e8) === "=");

                let e9 = seq(star(mut("f", "2")), star(mut("g", "3")));
                let e10 = seq(star(mut("g", "3")), star(mut("f", "2")));
                console.assert(decideLGE(e9, e10) === "=");

                let e11 = seq(alt(mut("f", "2"), mut("g", "3")), star(mut("f", "4")));
                let e12 = seq(alt(mut("g", "3"), mut("f", "2")), star(mut("f", "4")));
                console.assert(decideLGE(e11, e12) === "=");

                let e13 = seq(star(mut("f", "2")), alt(mut("g", "3"), mut("h", "4")));
                let e14 = seq(star(mut("f", "2")), alt(mut("h", "4"), mut("g", "3")));
                console.assert(decideLGE(e13, e14) === "=");

                let e15 = seq(star(alt(mut("f", "2"), mut("g", "3"))), mut("h", "4"));
                let e16 = seq(mut("h", "4"), star(alt(mut("f", "2"), mut("g", "3"))));
                console.assert(decideLGE(e15, e16) === "=");

                let e17 = seq(star(mut("f", "2")), star(alt(mut("g", "3"), mut("h", "4"))));
                let e18 = seq(star(alt(mut("g", "3"), mut("h", "4"))), star(mut("f", "2")));
                console.assert(decideLGE(e17, e18) === "=");

                // f := 2 + f := 3 < f := 2 + f := 2
                let e19 = alt(mut("f", "2"), mut("f", "3"));
                let e20 = alt(mut("f", "2"), mut("f", "2"));
                console.assert(decideLGE(e19, e20) === ">");

                let e23 = star(mut("f", "3"));
                let e24 = star(mut("f", "2"));
                console.assert(decideLGE(e23, e24) === "!=");

                let e21 = star(alt(mut("f", "2"), mut("f", "3")));
                let e22 = star(alt(mut("f", "2"), mut("f", "2")));
                console.assert(decideLGE(e21, e22) === ">");
            }

            // Test decide_equivalence_mixed_headers_push_pop
            function test_decide_equivalence_mixed_headers_push_pop() {
                let e1 = seq(pop("3"), seq(mut("f", "2"), seq(push("2"), seq(pop("2"), mut("f", "3")))));
                let e2 = seq(mut("f", "3"), pop("3"));
                console.assert(decideLGE(e1, e2) === "=");
            }

            // run the tests
            test_decide_equivalence_all();
            test_decide_equivalence_all_pure_headers();
            test_decide_equivalence_mixed_headers_push_pop();
        }

        let allExamples = [
            // --- test_decide_equivalence_all ---
            // e1 vs e2
            ["pop(2)* push(2)*", "(push(2) + pop(2))*"],
            // e1 vs e3
            ["pop(2)* push(2)*", "push(2)* (pop(2) pop(2))*"],
            // e1 vs e4
            ["pop(2)* push(2)*", "(pop(2) pop(2))* push(2)*"],
            // e1 vs e5
            ["pop(2)* push(2)*", "(push(2) push(2))* pop(2)*"],
            // e1 vs e6
            ["pop(2)* push(2)*", "pop(2)* (push(2) push(2))*"],
            // e2 vs e3
            ["(push(2) + pop(2))*", "push(2)* (pop(2) pop(2))*"],
            // e2 vs e4
            ["(push(2) + pop(2))*", "(pop(2) pop(2))* push(2)*"],
            // e2 vs e5
            ["(push(2) + pop(2))*", "(push(2) push(2))* pop(2)*"],
            // e2 vs e6
            ["(push(2) + pop(2))*", "pop(2)* (push(2) push(2))*"],
            // e3 vs e4
            ["push(2)* (pop(2) pop(2))*", "(pop(2) pop(2))* push(2)*"],
            // e3 vs e5
            ["push(2)* (pop(2) pop(2))*", "(push(2) push(2))* pop(2)*"],
            // e3 vs e6
            ["push(2)* (pop(2) pop(2))*", "pop(2)* (push(2) push(2))*"],
            // e4 vs e5
            ["(pop(2) pop(2))* push(2)*", "(push(2) push(2))* pop(2)*"],
            // e4 vs e6
            ["(pop(2) pop(2))* push(2)*", "pop(2)* (push(2) push(2))*"],
            // e5 vs e6
            ["(push(2) push(2))* pop(2)*", "pop(2)* (push(2) push(2))*"],

            // --- test_decide_equivalence_all_pure_headers ---
            // e1 vs e2
            ["f:=2 g:=3", "g:=3 f:=2"],
            // e3 vs e4
            ["f:=2 f==2", "f:=2 f:=2"],
            // e5 vs e6
            ["f:=2* g:=3", "g:=3 f:=2*"],
            // e7 vs e8
            ["(f:=2 + g:=3)*", "(g:=3 + f:=2)*"],
            // e9 vs e10
            ["f:=2* g:=3*", "g:=3* f:=2*"],
            // e11 vs e12
            ["(f:=2 + g:=3) f:=4*", "(g:=3 + f:=2) f:=4*"],
            // e13 vs e14
            ["f:=2* (g:=3 + h:=4)", "f:=2* (h:=4 + g:=3)"],
            // e15 vs e16
            ["(f:=2 + g:=3)* h:=4", "h:=4 (f:=2 + g:=3)*"],
            // e17 vs e18
            ["f:=2* (g:=3 + h:=4)*", "(g:=3 + h:=4)* f:=2*"],
            // e19 vs e20
            ["f:=2 + f:=3", "f:=2 + f:=2"],
            ["f:=2 + f==2", "f:=2"],
            // e23 vs e24
            ["f:=3*", "f:=2*"],
            // e21 vs e22
            ["(f:=2 + f:=3)*", "(f:=2 + f:=2)*"],

            // --- test_decide_equivalence_mixed_headers_push_pop ---
            // e1 vs e2
            ["pop(3) f:=2 push(2) pop(2) f:=3", "f:=3 pop(3)"],

            // more interesting examples
            [
                "f:=1 (f==1 f:=2 push(1) + f==2 f:=3 push(2))* f==3",
                "f:=1 f:=3 push(1) push(2)"
            ],
            [
                "f:=1 (f==1 push(1) + f==1 pop(1))* f:=2",
                "f:=1 (push(1) + pop(1))* f:=2"
            ],
            [
                "f:=2 push(1)* (f==2 pop(1))*",
                "f:=2 (push(1) + pop(1))*"
            ],
            [
                "f:=1 push(1)* f:=2",
                "f:=1 (push(1) + push(2))* f:=2"
            ]
        ];

        // tests();
    </script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f9f9f9;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 95%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin: 2rem 0;
            font-weight: 700;
            font-size: 2.5rem;
        }

        .content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        #controls {
            margin-bottom: 2rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        #randomExample {
            font-size: 1rem;
            padding: 5px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #randomExample:hover {
            background-color: #2980b9;
        }

        #randomExample:active {
            transform: translateY(1px);
        }

        #inputs {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            width: 100%;
            gap: 1rem;
        }

        .editor {
            position: relative;
            height: 120px;
            width: 100%;
            box-sizing: border-box;
            overflow: visible;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #e1e1e1;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 1rem;
            transition: box-shadow 0.3s ease;
        }

        .editor:hover {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .editor textarea,
        .editor .result {
            position: absolute;
            line-height: 1.6;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 16px;
            top: 16px;
            left: 16px;
            right: 16px;
            bottom: 16px;
            padding: 0;
            margin: 0;
            border: 0;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow: visible;
        }

        .editor textarea {
            background: transparent;
            color: transparent;
            caret-color: #333;
            z-index: 2;
            resize: none;
            outline: none;
        }

        .editor textarea:focus {
            outline: none;
        }

        .editor .result {
            color: transparent;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .correct {
            color: #333;
        }

        .incorrect {
            color: #e74c3c;
        }

        .rest {
            position: relative;
        }

        .message {
            position: absolute;
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 100;
            top: 30px;
            transform: translateX(-10px);
            white-space: nowrap;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .message::after {
            content: '';
            position: absolute;
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
            top: -12px;
            left: 20px;
            transform: translateX(-100%);
        }

        .result.correctstate .message {
            display: none;
        }

        .message code {
            background-color: #444;
            color: #2ecc71;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        #comparison {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 120px;
            font-size: 2rem;
            width: 60px;
            color: #2c3e50;
            font-weight: 500;
        }

        .counterexample {
            width: 100%;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            background-color: #f8f9fa;
            border-radius: 8px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            color: #444;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        .counterexample-title {
            font-weight: 600;
            padding: 0.4rem 0.5rem;
            border-bottom: 1px solid #e1e1e1;
            font-size: 1rem;
            color: #2c3e50;
            background-color: rgba(52, 152, 219, 0.1);
            border-top-right-radius: 8px;
            border-top-left-radius: 8px;
            text-align: center;
        }

        .counterexample-content {
            padding: 0.5rem 0.75rem;
            font-size: 0.95rem;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .counterexample-content div {
            margin-bottom: 0.3rem;
        }

        /* Spacing for detailed explanation */
        .counterexample-content .tooltip-container {
            margin: 0 2px;
            display: inline-flex;
        }

        .counterexample-content .tooltip-text {
            display: inline-flex;
        }

        .counterexample-content span[style*="white-space: nowrap"] {
            display: inline-flex;
            gap: 0;
        }

        .condensed-counter {
            background-color: #f1f8e9;
            padding: 0.3rem;
            margin-bottom: 0.5rem !important;
            border-radius: 4px;
            text-align: center;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            justify-content: center;
            gap: 1px;
        }

        .condensed-counter .stack-value,
        .condensed-counter .pk-value {
            margin: 0;
            padding: 2px 8px;
            display: inline-block;
        }

        /* Fix for tooltip spacing issue */
        .condensed-counter .tooltip-container {
            margin: 0;
            padding: 0;
            display: inline-flex;
            flex-shrink: 0;
        }

        .condensed-counter .tooltip-text {
            display: inline-flex;
            padding: 0;
            margin: 0;
        }

        .transform-label {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            font-size: 0.9rem;
            padding-right: 1px;
            margin-left: 2px;
        }

        .transform-arrow {
            font-weight: bold;
            color: #3498db;
            margin: 0 2px;
            font-size: 1.1rem;
        }

        .auto-pk {
            font-size: 0.9rem;
            margin: 0;
            padding: 2px 8px;
            display: inline-block;
        }

        /* Tooltip styles */
        .tooltip-container {
            display: inline-block;
            position: relative;
            cursor: help;
            margin: 0;
            padding: 0;
        }

        .tooltip-text {
            padding: 4px 8px;
            color: #2980b9;
        }

        .tooltip-content {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #34495e;
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            width: max-content;
            /* max-width: 200px; */
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #34495e transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .header {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            padding: 10px;
            background-color: #fff;
            width: 100%;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        /* Grammar section styles */
        .grammar-section {
            background-color: #f8f9fa;
            border-radius: 8px;
            margin: 1rem auto 2rem auto;
            overflow: hidden;
            max-width: 1200px;
            box-sizing: border-box;
        }

        .grammar-content {
            padding: 0.7rem 1rem 0.3rem 1rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #34495e;
            text-align: center;
        }

        .grammar-content > span {
            font-weight: 500;
            display: block;
            margin-bottom: 0.5rem;
        }

        .grammar-content code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            background-color: rgba(46, 204, 113, 0.05);
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            margin-left: 0.3rem;
        }

        .grammar-tooltips {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
            width: 100%;
        }

        .grammar-tooltip {
            position: relative;
            display: inline-block;
        }

        .grammar-term {
            background-color: #ecf0f1;
            padding: 5px 12px;
            border-radius: 4px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            color: #2c3e50;
            border-left: 3px solid #2ecc71;
            cursor: help;
            font-size: 1rem;
        }

        .grammar-tooltip .tooltip-content {
            visibility: hidden;
            position: fixed;  /* Changed from absolute to fixed */
            z-index: 999;     /* Higher z-index to ensure visibility */
            bottom: auto;     /* Remove fixed bottom positioning */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            width: 220px;     /* Reduced width */
            max-width: 90vw;  /* Responsive max-width */
            background-color: #34495e;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            pointer-events: none; /* Prevents tooltip from blocking interactions */
        }

        .grammar-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #34495e transparent transparent transparent;
            transform: translateX(-50%); /* Center the arrow */
        }

        .grammar-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        /* Counterexamples row styles */
        .counterexamples-row {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1.5rem auto;
            width: 100%;
            max-width: 1200px;
        }

        .counterexamples-row .counterexample {
            width: 48%;
            margin: 0;
            box-sizing: border-box;
            max-width: 580px;
        }

        .stack-value, .pk-value {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            display: inline-flex;
            margin: 0;
            white-space: nowrap;
        }

        /* Additional spacing fixes for counterexample content */
        .counterexample-content .stack-value,
        .counterexample-content .pk-value {
            margin: 0;
            padding: 2px 6px;
        }

        /* Normal letter spacing in detailed text */
        .counterexample-content {
            letter-spacing: normal;
        }

        /* This rule is redundant and has been moved above */

        /* Proper spacing for spans */
        .counterexample-content span {
            padding: 0;
        }

        /* Specific styles for condensed view */
        .condensed-counter .stack-value,
        .condensed-counter .pk-value {
            margin: 0;
            display: inline-flex;
            border-radius: 3px;
            padding: 2px 6px;
        }

        .pk-value {
            border-left: 3px solid #e74c3c;
        }

        .stack-value {
            border-left: 3px solid #2ecc71;
        }

        .empty-stack, .empty-pk {
            font-style: italic;
            color: #7f8c8d;
        }

        /* Removed different colors for top/bottom of stack as requested */
        .top-of-stack, .bottom-of-stack {
            /* Same styling as regular stack values */
        }

        .mid {
            width: 50px;
        }

        #cys {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 3rem;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
            margin-left: auto;
            margin-right: auto;
        }

        /* Two Column Layout */
        .two-column-layout {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            margin: 1.5rem auto;
            max-width: 1200px;
        }

        .column {
            width: 44%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .comparison-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 10%;
            margin-top: 1.5rem;
        }
        
        #comparison {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Ensure equal width for all elements in columns */
        .column > * {
            width: 100%;
        }

        .section-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            margin-top: 0.5rem;
            font-size: 1.1rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.5rem;
            text-align: center;
        }

        #cy1,
        #cy2 {
            width: 100%;
            height: 500px;
            border: 1px solid #e1e1e1;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            background-color: #fff;
            box-sizing: border-box;
        }

        .graph-title {
            text-align: center;
            margin-bottom: 0.5rem;
            color: #555;
            font-weight: 500;
            font-size: 1.1rem;
        }

        .packet-selector-container {
            max-width: 1200px;
            width: 100%;
            margin: 2rem auto 1rem auto;
            text-align: center;
            box-sizing: border-box;
            margin-top: 100px;
        }

        .packet-selectors {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            margin-top: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .packet-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .packet-selector label {
            font-weight: 500;
            color: #2c3e50;
            white-space: nowrap;
        }

        .packet-selector select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            background-color: #fff;
            min-width: 200px;
        }

        #update-automata {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        #update-automata:hover {
            background-color: #2980b9;
        }

        .graph-container {
            width: 48%;
            box-sizing: border-box;
            max-width: 580px;
        }

        footer {
            margin-top: 3rem;
            padding: 1rem;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        /* Responsive adjustments */
        @media (max-width: 1240px) {
            .two-column-layout,
            .counterexamples-row,
            #cys {
                max-width: 95%;
            }
        }

        @media (max-width: 992px) {
            #inputs {
                flex-direction: column;
                align-items: center;
            }

            .editor {
                width: 100%;
                margin-bottom: 1rem;
            }

            #comparison {
                height: 60px;
                margin: 0.5rem 0;
            }

            #cys {
                flex-direction: column;
                align-items: center;
            }

            #cy1, #cy2 {
                width: 100%;
                margin-bottom: 2rem;
            }

            .graph-container {
                width: 100%;
                margin-bottom: 2rem;
                box-sizing: border-box;
            }

            .counterexample {
                margin-top: 1rem;
                margin-bottom: 1rem;
            }

            .counterexample-content {
                font-size: 0.85rem;
            }

            .counterexamples-row {
                flex-direction: column;
                gap: 1rem;
            }

            .counterexamples-row .counterexample {
                width: 100%;
                max-width: 100%;
            }

            .packet-selectors {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }

            .packet-selector {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .packet-selector select {
                width: 100%;
            }

            .grammar-tooltips {
                gap: 0.3rem;
                padding: 0.5rem;
                justify-content: flex-start;
            }

            .grammar-section {
                margin: 0.5rem 0 1.5rem 0;
            }

            .grammar-content code {
                font-size: 0.9rem;
                padding: 0.3rem;
                display: inline-block;
                margin-top: 0.3rem;
                overflow-x: auto;
                max-width: 100%;
            }

            .grammar-content > span {
                line-height: 1.5;
            }
        }
        
        /* Timing display for equivalence check */
        .timing {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 5px;
            font-weight: normal;
            display: block;
        }
        
        /* Controls container */
        .controls-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        /* Benchmark tabs styling */
        /* Benchmark report styling */
        
        
    </style>
</head>

<body>
    <div class="container">
        <div class="two-column-layout">
            <div class="column left-column">
                <div class="editor" id="editor1">
                    <pre class="result"><span class="correct"></span><span class="rest"><span class="message"></span><span class="incorrect"></span></span></pre>
                    <textarea class="expr" placeholder="Enter first expression">pop(1)* push(1)</textarea>
                </div>
            </div>

            <div class="comparison-container">
                <div id="comparison">=</div>
            </div>

            <div class="column right-column">
                <div class="editor" id="editor2">
                    <pre class="result"><span class="correct"></span><span class="rest"><span class="message"></span><span class="incorrect"></span></span></pre>
                    <textarea class="expr" placeholder="Enter second expression">push(1)* pop(1)</textarea>
                </div>
            </div>
        </div>

            <div class="counterexamples-row">
                <div id="counterexampleA" class="counterexample">
                    <div class="counterexample-title">Counterexample (Left ⊃ Right)</div>
                    <div class="counterexample-content">Analyzing expressions...</div>
                </div>

                <div id="counterexampleB" class="counterexample">
                    <div class="counterexample-title">Counterexample (Left ⊂ Right)</div>
                    <div class="counterexample-content">Analyzing expressions...</div>
                </div>
            </div>

            <div class="packet-selector-container">
                <div class="section-title">Automata</div>
                <div class="packet-selectors">
                    <div class="packet-selector">
                        <label for="input-packet">Input Packet:</label>
                        <select id="input-packet"></select>
                    </div>
                    <div class="packet-selector">
                        <label for="output-packet">Output Packet:</label>
                        <select id="output-packet"></select>
                    </div>
                    <button id="update-automata">Update Automata</button>
                </div>
            </div>

            <div id="cys">
                <div class="graph-container">
                    <div class="graph-title">Left Expression Automaton</div>
                    <div id="cy1"></div>
                </div>

                <div class="graph-container">
                    <div class="graph-title">Right Expression Automaton</div>
                    <div id="cy2"></div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Fix tooltip positioning
        document.addEventListener('DOMContentLoaded', function() {
            const grammarTooltips = document.querySelectorAll('.grammar-tooltip');

            grammarTooltips.forEach(tooltip => {
                const tooltipContent = tooltip.querySelector('.tooltip-content');

                tooltip.addEventListener('mouseenter', function(e) {
                    const rect = tooltip.getBoundingClientRect();
                    const tooltipRect = tooltipContent.getBoundingClientRect();

                    // Position above the term with a small gap
                    tooltipContent.style.top = (rect.top - tooltipRect.height - 15) + 'px';
                    tooltipContent.style.left = (rect.left + rect.width/2) + 'px';
                });
            });
        });



        function mkEditor(selector, callback) {
            const editor = document.querySelector(selector);
            const expr = editor.querySelector('.expr');
            expr.addEventListener('input', () => {
                let input = expr.value;
                try {
                    let result = parse(input);
                    editor.querySelector('.correct').innerText = input;
                    editor.querySelector('.incorrect').innerText = '';
                    editor.querySelector('.message').innerText = '';
                    editor.querySelector('.result').classList.toggle('correctstate', true);
                    callback(result);
                } catch (e) {
                    if (!(e instanceof ParseError)) throw e;
                    let index = e.index;
                    let correct = e.input.slice(0, index);
                    let incorrect = e.input.slice(index);
                    editor.querySelector('.correct').innerText = correct;
                    editor.querySelector('.incorrect').innerText = incorrect;
                    editor.querySelector('.message').innerHTML = e.message;
                    editor.querySelector('.result').classList.toggle('correctstate', false);
                }
            });
            setTimeout(() => expr.dispatchEvent(new Event('input')), 0);
        }
        var result1 = null;
        var result2 = null;
        function minautemp(result, values) {
            return minaut(result, values, new Map(), new Map());
        }
        function pathToStackPair(path) {
            if (path === false) return false;
            let input = []
            let output = [];
            for (let elem of path) {
                let left = elem[1];
                let right = elem[2];
                if (left[0] == 'pop') {
                    input.push(left[1]);
                }
                if (right[0] == 'push') {
                    output.push(right[1]);
                }
            }
            // reverse them both
            input = input.reverse();
            output = output.reverse();
            return [input, output];
        }
        function displayCy(cy, aut) {
            let cyElems = automatonToCytoscape(aut);
            cy.json({ elements: cyElems });

            // Clear any previous elements if automaton is empty
            if (cyElems.nodes.length === 0) {
                cy.elements().remove();
                return;
            }

            cy.layout({
                name: 'cose',
                nodeRepulsion: function (node) { return 20000000; },
                idealEdgeLength: function (edge) { return 60; },
                padding: 40,
                animate: false,
                componentSpacing: 100,
                randomize: true,
                fit: true
            }).run();

            // After layout completes, fit the graph in the viewport
            setTimeout(() => {
                cy.fit();
                cy.center();
            }, 100);

            // Add tooltip event handlers
            cy.on('mouseover', 'node', function(e) {
                const node = e.target;
                const tooltip = node.data('tooltip');

                if (tooltip) {
                    const tooltipDiv = document.getElementById('cy-tooltip');
                    tooltipDiv.innerHTML = tooltip;
                    tooltipDiv.style.display = 'block';

                    // Position the tooltip near the node
                    const renderedPosition = node.renderedPosition();
                    const containerRect = cy.container().getBoundingClientRect();

                    tooltipDiv.style.left = (containerRect.left + renderedPosition.x + 10) + 'px';
                    tooltipDiv.style.top = (containerRect.top + 500 + renderedPosition.y - 40) + 'px';

                    // Add a small delay before showing to avoid flickering
                    setTimeout(() => {
                        tooltipDiv.style.opacity = '1';
                    }, 50);
                }
            });

            cy.on('mouseout', 'node', function() {
                const tooltipDiv = document.getElementById('cy-tooltip');
                tooltipDiv.style.opacity = '0';

                // Wait for transition to complete before hiding
                setTimeout(() => {
                    tooltipDiv.style.display = 'none';
                }, 200);
            });

            // Also hide tooltip when panning or zooming
            cy.on('pan zoom', function() {
                const tooltipDiv = document.getElementById('cy-tooltip');
                tooltipDiv.style.opacity = '0';
                tooltipDiv.style.display = 'none';
            });
        }
        // Global variables for packet configurations
        let allPackets = [];
        let selectedInputPacket = null;
        let selectedOutputPacket = null;

        // Function to update packet selectors
        function updatePacketSelectors() {
            if (!result1 || !result2) return;

            // Get all packet header variables
            const dom1 = dom(result1);
            const dom2 = dom(result2);
            const allDomains = new Map();

            // Merge domains
            for (const [key, values] of dom1.entries()) {
                allDomains.set(key, new Set(values));
            }

            for (const [key, values] of dom2.entries()) {
                if (!allDomains.has(key)) {
                    allDomains.set(key, new Set(values));
                } else {
                    for (const value of values) {
                        allDomains.get(key).add(value);
                    }
                }
            }

            // Generate all possible packet combinations
            allPackets = allpks(allDomains);

            // Clear existing options
            const inputSelect = document.getElementById('input-packet');
            const outputSelect = document.getElementById('output-packet');
            inputSelect.innerHTML = '';
            outputSelect.innerHTML = '';

            // Add empty option
            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select a packet configuration --';
            inputSelect.appendChild(emptyOption.cloneNode(true));
            outputSelect.appendChild(emptyOption);

            // Add option for each packet
            allPackets.forEach((packet, index) => {
                const pkEntries = Array.from(packet.entries());
                const pkText = pkEntries.length > 0
                    ? `{${pkEntries.map(([k, v]) => `${k}=${v}`).join(', ')}}`
                    : '{empty}';

                const option = document.createElement('option');
                option.value = index;
                option.textContent = pkText;

                inputSelect.appendChild(option.cloneNode(true));
                outputSelect.appendChild(option.cloneNode(true));
            });

            // Set default selections
            if (allPackets.length > 0) {
                inputSelect.value = '';
                outputSelect.value = '';
            }

            // Update selected packets
            selectedInputPacket = null;
            selectedOutputPacket = null;
        }

        // Function to initialize event listeners
        function initEventListeners() {
            document.getElementById('update-automata').addEventListener('click', function() {
                const inputIndex = document.getElementById('input-packet').value;
                const outputIndex = document.getElementById('output-packet').value;

                if (inputIndex !== '' && outputIndex !== '') {
                    selectedInputPacket = allPackets[parseInt(inputIndex)];
                    selectedOutputPacket = allPackets[parseInt(outputIndex)];
                    updateAutomata();
                    updateAutomataTitle();
                }
            });
        }

        // Function to update automata titles
        function updateAutomataTitle() {
            if (!selectedInputPacket || !selectedOutputPacket) {
                document.querySelector('.graph-container:nth-child(1) .graph-title').textContent = 'Left Expression Automaton';
                document.querySelector('.graph-container:nth-child(2) .graph-title').textContent = 'Right Expression Automaton';
                return;
            }

            // Format packet headers using the same style as counterexamples
            const formatPacket = (pk) => {
                if (!pk || pk.size === 0) return 'Empty';

                const entries = Array.from(pk.entries());
                const pkHtml = entries.map(([key, value]) =>
                    `<span class="pk-value auto-pk">${key}=${value}</span>`
                ).join(' ');

                return pkHtml;
            };

            const inputPkHtml = formatPacket(selectedInputPacket);
            const outputPkHtml = formatPacket(selectedOutputPacket);

            document.querySelector('.graph-container:nth-child(1) .graph-title').innerHTML =
                `Left Expression Automaton (${inputPkHtml} <span class="transform-arrow">→</span> ${outputPkHtml})`;
            document.querySelector('.graph-container:nth-child(2) .graph-title').innerHTML =
                `Right Expression Automaton (${inputPkHtml} <span class="transform-arrow">→</span> ${outputPkHtml})`;
        }

        // Initialize event listeners when document is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initEventListeners();
        });

        // Function to update automata displays
        function updateAutomata() {
            if (!result1 || !result2 || !selectedInputPacket || !selectedOutputPacket) return;

            let values = Array.from(new Set(getValues(result1).concat(getValues(result2))));
            let automaton1 = minaut(result1, values, selectedInputPacket, selectedOutputPacket);
            let automaton2 = minaut(result2, values, selectedInputPacket, selectedOutputPacket);

            displayCy(cy1, automaton1);
            displayCy(cy2, automaton2);
        }

        function recompute() {
            if (!result1 || !result2) return;
            
            let values = Array.from(new Set(getValues(result1).concat(getValues(result2))));
            
            let automaton1 = minautemp(result1, values);
            let automaton2 = minautemp(result2, values);
            
            // Add timing measurement
            const startTime = performance.now();
            let [path1, respks1, path2, respks2] = decide(result1, result2);
            const endTime = performance.now();
            const executionTime = endTime - startTime;
            
            console.log("path1", path1);
            console.log("respks1", respks1);
            console.log("path2", path2);
            console.log("respks2", respks2);
            
            let comparisonSymbol = '';
            if (path1 === false && path2 === false) {
                comparisonSymbol = '=';
            } else if (path1 === false) {
                comparisonSymbol = '⊂';
            } else if (path2 === false) {
                comparisonSymbol = '⊃';
            } else {
                comparisonSymbol = '≠';
            }
            
            // Display comparison result with timing information
            document.getElementById('comparison').innerHTML = `${comparisonSymbol} <span class="timing">(${executionTime.toFixed(2)} ms)</span>`;

            updatePacketSelectors();

            // Helper functions for formatting and tooltips
            function createTooltip(text, explanation) {
                // Remove any whitespace from the text parameter if it's a string
                if (typeof text === 'string') {
                    text = text.trim();
                }
                return `<div class="tooltip-container"><span class="tooltip-text">${text}</span><div class="tooltip-content">${explanation}</div></div>`;
            }

            function formatStackValues(values) {
                if (!values || values.length === 0) {
                    return createTooltip('<span class="stack-value empty-stack">ε</span>', 'Empty stack (epsilon)');
                }

                const stackValues = [...values];
                let result = '<span style="white-space: nowrap;">';

                // First item is at the top of the stack
                if (stackValues.length > 0) {
                    const topValue = stackValues[0];
                    result += `<div class="tooltip-container"><span class="stack-value top-of-stack">${topValue}</span><div class="tooltip-content">Top of stack</div></div>`;
                }

                // Middle values (if any)
                for (let i = 1; i < stackValues.length - 1; i++) {
                    result += `<span class="stack-value">${stackValues[i]}</span>`;
                }

                // Last item is at the bottom of the stack (if more than one item)
                if (stackValues.length > 1) {
                    const bottomValue = stackValues[stackValues.length - 1];
                    result += `<div class="tooltip-container"><span class="stack-value bottom-of-stack">${bottomValue}</span><div class="tooltip-content">Bottom of stack</div></div>`;
                }

                return result + '</span>';
            }

            function formatPkValues(pk) {
                if (!pk || pk.size === 0) {
                    return createTooltip('<span class="pk-value empty-pk">∅</span>', 'Empty packet headers');
                }
                const entries = Array.from(pk.entries());
                const pkValues = entries.map(([key, value]) => {
                    let tooltip = `Packet header ${key}=${value}`;
                    if (value === "?") {
                        tooltip = `Packet header ${key} is uninitialized`;
                    }
                    return createTooltip(`<span class="pk-value">${key}=${value}</span>`, tooltip);
                }).join('');

                return `<span style="white-space: nowrap; display:inline-flex;">${pkValues}</span>`;
            }

            function formatStackStyled(stack) {
                if (!stack || stack.length === 0) {
                    return createTooltip('<span class="stack-value empty-stack">ε</span>', 'Empty stack (epsilon)');
                }

                if (stack.length === 1) {
                    return createTooltip(
                        `<span class="stack-value top-of-stack">${stack[0]}</span>`,
                        'Top of stack'
                    );
                }

                const stackValues = stack.map((val, idx) => {
                    if (idx === 0) {
                        return createTooltip(
                            `<span class="stack-value top-of-stack">${val}</span>`,
                            'Top of stack'
                        );
                    } else if (idx === stack.length - 1) {
                        return createTooltip(
                            `<span class="stack-value bottom-of-stack">${val}</span>`,
                            'Bottom of stack'
                        );
                    } else {
                        const ordinals = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth'];
                        return createTooltip(`<span class="stack-value">${val}</span>`, `${ordinals[idx]} value on stack`);
                    }
                }).join('');

                return `<span style="white-space: nowrap; display:inline-flex;">${stackValues}</span>`;
            }

            function formatCounterexample(path, respks, isLeft) {
                if (path === false) {
                    const direction = isLeft ? 'Left' : 'Right';
                    const symbol = isLeft ? '⊆' : '⊆';
                    document.getElementById(`counterexample${isLeft ? 'A' : 'B'}`).querySelector('.counterexample-content').innerHTML =
                        `No counterexample found. ${direction} expression is a subset of or equal to ${isLeft ? 'right' : 'left'} expression.`;
                    document.getElementById(`counterexample${isLeft ? 'A' : 'B'}`).querySelector('.counterexample-title').innerHTML =
                        `No Counterexample (${direction} ${symbol} ${isLeft ? 'Right' : 'Left'})`;
                    return;
                }

                let [input, output] = pathToStackPair(path);
                let [inpk, outpk] = respks;

                const condensedFormat = `<div class="condensed-counter"><span class="transform-label">Input:&nbsp;</span>${formatPkValues(inpk)}${formatStackStyled(input)}<span class="transform-arrow">&nbsp;→&nbsp;</span><span class="transform-label">Output:&nbsp;</span>${formatPkValues(outpk)}${formatStackStyled(output)}</div>`;

                const content = `${condensedFormat}
                <div>Starting with packet headers ${formatPkValues(inpk)} and input stack ${formatStackStyled(input)},
                    the ${isLeft ? 'left' : 'right'} expression produces output stack ${formatStackStyled(output)} with packet headers ${formatPkValues(outpk)},
                    but the ${isLeft ? 'right' : 'left'} expression does not produce this input/output combination.</div>`;

                document.getElementById(`counterexample${isLeft ? 'A' : 'B'}`).querySelector('.counterexample-content').innerHTML = content;
                document.getElementById(`counterexample${isLeft ? 'A' : 'B'}`).querySelector('.counterexample-title').innerHTML =
                    `Counterexample (Left ${isLeft ? '⊃' : '⊂'} Right)`;
            }

            // Format counterexamples for both left and right cases
            formatCounterexample(path1, respks1, true);
            formatCounterexample(path2, respks2, false);
            
            // Update cytoscape graphs
            displayCy(cy1, automaton1);
            displayCy(cy2, automaton2);
        }
        mkEditor('#editor1', function (result) {
            result1 = result;
            recompute();
        })
        mkEditor('#editor2', function (result) {
            result2 = result;
            recompute();
        })
    </script>

    <script>
        function initCy(id) {
            // Create tooltip div if it doesn't exist
            let tooltipDiv = document.getElementById('cy-tooltip');
            if (!tooltipDiv) {
                tooltipDiv = document.createElement('div');
                tooltipDiv.id = 'cy-tooltip';
                tooltipDiv.style.position = 'absolute';
                tooltipDiv.style.display = 'none';
                tooltipDiv.style.backgroundColor = '#34495e';
                tooltipDiv.style.color = 'white';
                tooltipDiv.style.padding = '8px 12px';
                tooltipDiv.style.borderRadius = '4px';
                tooltipDiv.style.fontSize = '13px';
                tooltipDiv.style.pointerEvents = 'none';
                tooltipDiv.style.zIndex = '1000';
                tooltipDiv.style.opacity = '0';
                tooltipDiv.style.transition = 'opacity 0.2s';
                tooltipDiv.style.boxShadow = '0 3px 6px rgba(0,0,0,0.2)';
                tooltipDiv.style.textAlign = 'center';
                tooltipDiv.style.lineHeight = '1.4';
                document.body.appendChild(tooltipDiv);
            }

            const cy = cytoscape({
                container: document.getElementById(id),
                elements: {
                    nodes: [
                        { data: { id: 'q0', label: 'q0', tooltip: 'Example state' } },
                        { data: { id: 'q1', label: 'q1', tooltip: 'Example state' } },
                        { data: { id: 'q2', label: 'q2', tooltip: 'Example state' } }
                    ],
                    edges: [
                        { data: { source: 'q0', target: 'q0', label: 'push(0)' } },
                        { data: { source: 'q0', target: 'q1', label: 'push(1)' } },
                        { data: { source: 'q1', target: 'q0', label: 'push(0)' } },
                        { data: { source: 'q1', target: 'q1', label: 'push(1)' } },
                        { data: { source: 'q1', target: 'q2', label: 'push(0)' } },
                        { data: { source: 'q2', target: 'q0', label: 'push(0)' } },
                        { data: { source: 'q2', target: 'q1', label: 'push(1)' } }
                    ]
                },
                style: [
                    {
                        selector: 'node',
                        style: {
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'width': '20px',
                            'height': '20px',
                            'font-size': '18px',
                            'border-width': '2px',
                            'border-color': '#fff',
                            'background-color': '#3498db',
                        },
                    },
                    {
                        selector: '.accept',
                        style: {
                            'background-color': '#fff',
                            'border-color': '#3498db',
                            'border-width': '3px',
                        }
                    },
                    {
                        selector: '.start',
                        style: {
                            'background-color': '#2ecc71',
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#95a5a6',
                            'target-arrow-color': '#7f8c8d',
                            'target-arrow-shape': 'triangle',
                            'arrow-scale': 1,
                            'target-distance-from-node': 2,
                            'curve-style': 'bezier',
                            'control-point-step-size': 60,
                            'label': 'data(label)',
                            'text-rotation': 'autorotate',
                            'font-size': '16px',
                            'text-outline-width': 4,
                            'text-outline-color': '#fff',
                            'color': '#34495e',
                            'text-margin-y': -6,
                        }
                    }
                ],
                layout: {
                    name: 'cose',
                }
            });
            return cy;
        }
        var cy1 = initCy('cy1');
        var cy2 = initCy('cy2');
    </script>
</body>

</html>